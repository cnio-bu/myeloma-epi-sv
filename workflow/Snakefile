import os


configfile: "config/config.yaml"


def get_resource(rule, resource):
    try:
        return config["resources"][rule][resource]
    except KeyError:
        return config["resources"]["default"][resource]

def input_main(wc):
    o = []
    for sid in config["samples"]:
        for bc in config["basecallers"]:
            for filt in config["filters"]:
                o.append(f"results/pycoqc/{sid}/{bc}.html")
                for ref in config["paths"]["references"]:
                    o.append(f"results/primary/{sid}/{ref}/dorado-{filt}.cov")
                    o.append(f"results/mosdepth/{sid}/{ref}/dorado-{filt}.mosdepth.global.dist.txt")
                    o.append(f"results/modkit/pileup/{sid}/{ref}/dorado-{filt}.bed.gz.tbi")
	            for mod in ["m","h"]:
                        for strand in ["fw","rv"]:
                            o.append(f"results/modkit/pileup/{sid}/{ref}/dorado-{filt}.{mod}.{strand}.bw")
    return o


rule main:
    input:
        input_main,


rule basecall_dorado:
    input:
        lambda wc: config["samples"][wc.sampleid]["pod5"],
    output:
        "results/basecall/{sampleid}/dorado.bam",
    log:
        "logs/basecall_dorado/{sampleid}/dorado.log",
    benchmark:
        "logs/basecall_dorado/{sampleid}/dorado.bmk"
    params:
        bin=config["basecallers"]["dorado"]["bin"],
        model=get_resource("basecall_dorado", "params_model"),
        extra=get_resource("basecall_dorado", "params_extra"),
    threads: get_resource("basecall_dorado", "threads")
    resources:
        mem_mb=get_resource("basecall_dorado", "mem_mb"),
        runtime=get_resource("basecall_dorado", "runtime"),
        slurm_partition=get_resource("basecall_dorado", "partition"),
        slurm_extra=get_resource("basecall_dorado", "slurm_extra"),
    shell:
        """
        {params.bin} basecaller {params.model} {input} {params.extra} > {output} 2> {log}
    """


rule summary_dorado:
    input:
        "results/basecall/{sampleid}/dorado.bam",
    output:
        "results/summary_dorado/{sampleid}/dorado.txt",
    log:
        "logs/summary_dorado/{sampleid}/dorado.log",
    benchmark:
        "logs/summary_dorado/{sampleid}/dorado.bmk"
    params:
        bin=config["basecallers"]["dorado"]["bin"],
    threads: get_resource("summary_dorado", "threads")
    resources:
        mem_mb=get_resource("summary_dorado", "mem_mb"),
        runtime=get_resource("summary_dorado", "runtime"),
        slurm_partition=get_resource("summary_dorado", "partition"),
        slurm_extra=get_resource("summary_dorado", "slurm_extra"),
    shell:
        """
        {params.bin} summary {input} >> {output} 2> {log}
    """


rule pycoqc:
    input:
        "results/summary_dorado/{sampleid}/dorado.txt",
    output:
        "results/pycoqc/{sampleid}/{basecaller}.html",
    log:
        "logs/pycoqc/{sampleid}/{basecaller}.log",
    benchmark:
        "logs/pycoqc/{sampleid}/{basecaller}.bmk"
    threads: get_resource("pycoqc", "threads")
    conda:
        "envs/pycoqc.yaml"
    resources:
        mem_mb=get_resource("pycoqc", "mem_mb"),
        runtime=get_resource("pycoqc", "runtime"),
        slurm_partition=get_resource("pycoqc", "partition"),
        slurm_extra=get_resource("pycoqc", "slurm_extra"),
    shell:
        """
       pycoQC -f {input} -o {output} 2>&1 > {log}
    """


def getcmp(wc):
    if wc.cmp == "ge":
        return ">="
    elif wc.cmp == "gt":
        return ">"
    elif wc.cmp == "le":
        return "<="
    elif wc.cmp == "lt":
        return "<"
    else:
        raise ValueError(f"Operator {wc.cmp} not recognised")

rule qsfilter:
    input:
        "results/basecall/{sampleid}/{basecaller}.bam",
    output:
        "results/qsfilter/{sampleid}/{basecaller}-{cmp}-{qscore}.bam",
    log:
        "logs/qsfilter/{sampleid}/{basecaller}-{cmp}-{qscore}.log",
    benchmark:
        "logs/qsfilter/{sampleid}/{basecaller}-{cmp}-{qscore}.bmk"
    params:
        cmp=getcmp,
        qscore=lambda wc: wc.qscore.lstrip("0"),
    threads: get_resource("qsfilter", "threads")
    resources:
        mem_mb=get_resource("qsfilter", "mem_mb"),
        runtime=get_resource("qsfilter", "runtime"),
        slurm_partition=get_resource("qsfilter", "partition"),
    conda:
        "envs/samtools.yaml"
    shell:
        """
        samtools view -e '[qs]{params.cmp}{params.qscore}' {input} > {output} 2> {log}
    """


rule minimap2:
    input:
        reads="results/qsfilter/{sampleid}/{basecaller}-{cmp}-{qscore}.bam",
        ref=lambda wc: config["paths"]["references"][wc.ref],
    output:
        "results/minimap2/{sampleid}/{ref}/{basecaller}-{cmp}-{qscore}.bam",
    log:
        "logs/minimap2/{sampleid}/{ref}/{basecaller}-{cmp}-{qscore}.log",
    benchmark:
        "logs/minimap2/{sampleid}/{ref}/{basecaller}-{cmp}-{qscore}.bmk"
    threads: get_resource("minimap2", "threads")
    resources:
        mem_mb=get_resource("minimap2", "mem_mb"),
        runtime=get_resource("minimap2", "runtime"),
        slurm_partition=get_resource("minimap2", "partition"),
    conda:
        "envs/minimap2.yaml"
    shell:
        """
        samtools fastq -T "*" {input.reads} | minimap2 -a -x map-ont -y -t {threads} {input.ref} - | samtools sort - -o {output} 2> {log}
        samtools index {output}
    """

rule primary:
    input:
        "results/minimap2/{sampleid}/{ref}/{basecaller}-{cmp}-{qscore}.bam",
    output:
        bam="results/primary/{sampleid}/{ref}/{basecaller}-{cmp}-{qscore}.bam",
        bai="results/primary/{sampleid}/{ref}/{basecaller}-{cmp}-{qscore}.bam.bai",
    log:
        "logs/primary/{sampleid}/{ref}/{basecaller}-{cmp}-{qscore}.log",
    benchmark:
        "logs/primary/{sampleid}/{ref}/{basecaller}-{cmp}-{qscore}.bmk"
    threads: lambda wc: get_resource("primary", "threads")/2
    resources:
        mem_mb=get_resource("primary", "mem_mb"),
        runtime=get_resource("primary", "runtime"),
        slurm_partition=get_resource("primary", "partition"),
    conda:
        "envs/samtools.yaml"
    shell:
        """
        samtools view -@ {threads} -F 2308 -b {input} | samtools sort -@ {threads} -o {output.bam} 2> {log}
        samtools index {output.bam}
    """

rule coverage:
    input:
        "results/primary/{sampleid}/{ref}/{basecaller}-{cmp}-{qscore}.bam",
    output:
        "results/primary/{sampleid}/{ref}/{basecaller}-{cmp}-{qscore}.cov",
    log:
        "logs/coverage/{sampleid}/{ref}/{basecaller}-{cmp}-{qscore}.log",
    benchmark:
        "logs/coverage/{sampleid}/{ref}/{basecaller}-{cmp}-{qscore}.bmk"
    resources:
        mem_mb=get_resource("coverage", "mem_mb"),
        runtime=get_resource("coverage", "runtime"),
        slurm_partition=get_resource("coverage", "partition"),
    conda:
        "envs/samtools.yaml"
    shell:
        """
        samtools coverage -A -o {output} {input} &> {log}
    """

rule mosdepth:
    input:
        bam="results/primary/{sampleid}/{ref}/{basecaller}-{cmp}-{qscore}.bam",
        bai="results/primary/{sampleid}/{ref}/{basecaller}-{cmp}-{qscore}.bam.bai",
    output:
        "results/mosdepth/{sampleid}/{ref}/{basecaller}-{cmp}-{qscore}.mosdepth.global.dist.txt",
        "results/mosdepth/{sampleid}/{ref}/{basecaller}-{cmp}-{qscore}.per-base.bed.gz",
        summary="results/mosdepth/{sampleid}/{ref}/{basecaller}-{cmp}-{qscore}.mosdepth.summary.txt",
    log:
        "logs/mosdepth/{sampleid}/{ref}/{basecaller}-{cmp}-{qscore}.log",
    benchmark:
        "logs/mosdepth/{sampleid}/{ref}/{basecaller}-{cmp}-{qscore}.bmk"
    threads: get_resource("mosdepth", "threads"),
    resources:
        mem_mb=get_resource("mosdepth", "mem_mb"),
        runtime=get_resource("mosdepth", "runtime"),
        slurm_partition=get_resource("mosdepth", "partition"),
    wrapper:
        "v3.1.0/bio/mosdepth"

rule modkit_pileup:
    input:
        bam="results/primary/{sampleid}/{ref}/{basecaller}-{cmp}-{qscore}.bam",
        bai="results/primary/{sampleid}/{ref}/{basecaller}-{cmp}-{qscore}.bam.bai",
    output:
        bed="results/modkit/pileup/{sampleid}/{ref}/{basecaller}-{cmp}-{qscore}.bed",
        #bgzip="results/modkit/pileup/{sampleid}/{ref}/{basecaller}-{cmp}-{qscore}.bed.gz",
        #tabix="results/modkit/pileup/{sampleid}/{ref}/{basecaller}-{cmp}-{qscore}.bed.gz.tbi",
    log:
        "logs/modkit/pileup/{sampleid}/{ref}/{basecaller}-{cmp}-{qscore}.log",
    benchmark:
        "logs/modkit/pileup/{sampleid}/{ref}/{basecaller}-{cmp}-{qscore}.bmk"
    threads: get_resource("modkit_pileup", "threads"),
    resources:
        mem_mb=get_resource("modkit_pileup", "mem_mb"),
        runtime=get_resource("modkit_pileup", "runtime"),
        slurm_partition=get_resource("modkit_pileup", "partition"),
    params:
        bin=config["modkit"]["bin"],
    shell:"""
        {params.bin} pileup {input.bam} {output.bed} \
          --threads {threads} \
          --log-filepath {log}
    """

rule modkit_tabix:
    input:
        bed="results/modkit/pileup/{sampleid}/{ref}/{basecaller}-{cmp}-{qscore}.bed",
    output:
        bgzip="results/modkit/pileup/{sampleid}/{ref}/{basecaller}-{cmp}-{qscore}.bed.gz",
        tabix="results/modkit/pileup/{sampleid}/{ref}/{basecaller}-{cmp}-{qscore}.bed.gz.tbi",
    log:
        "logs/modkit/tabix/{sampleid}/{ref}/{basecaller}-{cmp}-{qscore}.log",
    benchmark:
        "logs/modkit/tabix/{sampleid}/{ref}/{basecaller}-{cmp}-{qscore}.bmk"
    threads: get_resource("modkit_tabix", "threads"),
    resources:
        mem_mb=get_resource("modkit_tabix", "mem_mb"),
        runtime=get_resource("modkit_tabix", "runtime"),
        slurm_partition=get_resource("modkit_tabix", "partition"),
    conda:
        "envs/samtools.yaml"
    shell:"""
        bgzip {input.bed} &> {log}
        tabix {output.bgzip} &> {log}
    """

rule bedmethyl_to_bg:
    input:
        bedmethyl="results/modkit/pileup/{sampleid}/{ref}/{basecaller}-{cmp}-{qscore}.bed.gz",
    output:
        mfw=temp("results/modkit/pileup/{sampleid}/{ref}/{basecaller}-{cmp}-{qscore}.m.fw.bedgraph"),
        hfw=temp("results/modkit/pileup/{sampleid}/{ref}/{basecaller}-{cmp}-{qscore}.h.fw.bedgraph"),
        mrv=temp("results/modkit/pileup/{sampleid}/{ref}/{basecaller}-{cmp}-{qscore}.m.rv.bedgraph"),
        hrv=temp("results/modkit/pileup/{sampleid}/{ref}/{basecaller}-{cmp}-{qscore}.h.rv.bedgraph"),
    threads: get_resource("bedmethyl_to_bg", "threads"),
    resources:
        mem_mb=get_resource("bedmethyl_to_bg", "mem_mb"),
        runtime=get_resource("bedmethyl_to_bg", "runtime"),
        slurm_partition=get_resource("bedmethyl_to_bg", "partition"),
    log:
        o="logs/modkit/bedmethyl_to_bg/{sampleid}/{ref}/{basecaller}-{cmp}-{qscore}.out",
        e="logs/modkit/bedmethyl_to_bg/{sampleid}/{ref}/{basecaller}-{cmp}-{qscore}.err",
    script:"scripts/bmtobg.py"

rule bedgraphtobigwig:
    input:
        bedGraph="results/modkit/pileup/{sampleid}/{ref}/{basecaller}-{cmp}-{qscore}.{mod}.{strand}.bedgraph",
        chromsizes="/storage/scratch01/users/tdidomenico/res/genomes/h_sapiens/gencode/v38/GRCh38.chronly.genome.chrsizes"
    output:
        "results/modkit/pileup/{sampleid}/{ref}/{basecaller}-{cmp}-{qscore}.{mod}.{strand}.bw",
    log:
        "logs/modkit/bedgraphtobigwig/{sampleid}/{ref}/{basecaller}-{cmp}-{qscore}-{mod}.{strand}.log",
    params:
        "" # optional params string
    resources:
        mem_mb=get_resource("bedgraphtobigwig", "mem_mb"),
        runtime=get_resource("bedgraphtobigwig", "runtime"),
        slurm_partition=get_resource("bedgraphtobigwig", "partition"),
    wrapper:
        "v3.7.0/bio/ucsc/bedGraphToBigWig"
